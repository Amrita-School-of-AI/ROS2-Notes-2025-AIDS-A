## MAKE & NINJA (BUILD SYSTEM)

To make the comparison clear on **Makefiles** (GNU Make) and **Ninja** files, let's assume a simple C++ project with three files:

1.  `main.cpp` (The entry point)
2.  `math.cpp` (Source for a library)
3.  `math.h` (Header file)

---

### **1. The Makefile (GNU Make)**

Makefiles are human-readable but rely on strict formatting (specifically tab characters). They work by checking file modification timestamps.

**Filename:** `Makefile`

```makefile
# --- Variables ---
CXX = g++
CXXFLAGS = -Wall -g
TARGET = my_app
OBJS = main.o math.o

# --- The First Target is the Default ---
# Syntax: target: dependencies
# <TAB> command
all: $(TARGET)

# --- Linking Step ---
# Creates the executable from object files
$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) -o $(TARGET) $(OBJS)

# --- Compilation Steps ---
# Compiles main.cpp into main.o
main.o: main.cpp math.h
	$(CXX) $(CXXFLAGS) -c main.cpp

# Compiles math.cpp into math.o
math.o: math.cpp math.h
	$(CXX) $(CXXFLAGS) -c math.cpp

# --- Utilities ---
# .PHONY prevents conflict if a file named 'clean' actually exists
.PHONY: clean
clean:
	rm -f $(OBJS) $(TARGET)
```

**Key Takeaways:**

- **The Tab Rule:** You **must** use a hard Tab character at the start of a command line. Spaces will cause a "missing separator" error.
- **Implicit Rules:** Make is smart. Often `main.o: main.cpp` is enough, and Make guesses the compile command. (I wrote it explicitly above for clarity).
- **Recursive:** You can include other Makefiles, but it gets messy quickly.

---

### **2. The Ninja File (`build.ninja`)**

Ninja is designed to be generated by other programs (like CMake or Meson). It is optimized for speed and parallelism, not for human writing. It is much simpler and "flatter" than Make.

**Filename:** `build.ninja`

```ninja
# --- Variables ---
cxx = g++
cflags = -Wall -g

# --- Rules (How to do things) ---
# Defines a "template" for a command
rule compile
  command = $cxx $cflags -c $in -o $out
  description = Compiling $in...

rule link
  command = $cxx $in -o $out
  description = Linking $out...

# --- Build Statements (What to do) ---
# Syntax: build <output>: <rule_name> <input>

build main.o: compile main.cpp
build math.o: compile math.cpp

# Implicit dependency: The executable depends on the .o files
build my_app: link main.o math.o

# --- Default Target ---
default my_app
```

**Key Takeaways for Memory Refresh:**

- **No Logic:** Ninja has almost no logic (no `if`, no loops). It just executes a dependency graph.
- **`$in` and `$out`:** Special variables representing the input files and output files defined in the `build` line.
- **Flat Structure:** Large Ninja files are usually just thousands of `build` lines listed sequentially. This makes it incredibly fast for the tool to parse compared to Make.

## CMAKE

### **Level 1: The Absolute Basics**

**Goal:** Understand the syntax and the "out-of-source" build workflow.

#### 1.1 The Minimum Viable CMakeLists.txt

Every CMake project starts with a `CMakeLists.txt` file in the root directory.

```cmake
cmake_minimum_required(VERSION 3.25) # Always specify a minimum version
project(MyProject VERSION 1.0.0 LANGUAGES CXX)

# Create an executable named 'MyApp' from 'main.cpp'
add_executable(MyApp main.cpp)
```

#### 1.2 The Build Workflow (Out-of-Source)

Never run `cmake .`. It clutters your source folder. Always use a separate build directory.

1.  **Generate:** Create build files (Makefiles, Ninja files, VS Solution) from `CMakeLists.txt`.
    ```bash
    mkdir build
    cd build
    cmake ..  # ".." points to the parent dir where CMakeLists.txt lives
    ```
2.  **Build:** Compile the code using the generated files.
    ```bash
    cmake --build .
    ```

---

### **Level 2: Modern CMake (Targets & Properties)**

**Goal:** Stop using global variables (`include_directories`, `link_libraries`) and start using **Targets**.

#### 2.1 The Philosophy

Think of a **Target** (executable or library) as an object. You attach **Properties** (includes, definitions, compiler flags) to it.

- **Global (Bad):** `include_directories(...)` affects _everything_ after it.
- **Target-based (Good):** `target_include_directories(mytarget ...)` affects _only_ that target.

#### 2.2 Scope Keywords: PUBLIC, PRIVATE, INTERFACE

These control how build requirements propagate to consumers of your library.

- **PRIVATE:** "I need this to build myself, but users of my library don't need it." (e.g., an internal math helper).
- **INTERFACE:** "I don't need this to build, but users of my library do." (e.g., a header-only library).
- **PUBLIC:** "I need this, and users of my library need it too." (e.g., a header file that `#include`s a 3rd party library).

#### 2.3 Example: Library & App Structure

**File Structure:**

```text
/
├── CMakeLists.txt
├── include/
│   └── mylib/
│       └── math.h
├── src/
│   ├── math.cpp
│   └── main.cpp
```

**CMakeLists.txt:**

```cmake
cmake_minimum_required(VERSION 3.25)
project(MathApp)

# --- 1. Define the Library ---
add_library(MathLib src/math.cpp)

# Define where headers are.
# INTERFACE: Consumers need to know this path to include "mylib/math.h"
target_include_directories(MathLib PUBLIC
    "${CMAKE_CURRENT_SOURCE_DIR}/include"
)

# --- 2. Define the Executable ---
add_executable(Calculator src/main.cpp)

# Link the app to the library
target_link_libraries(Calculator PRIVATE MathLib)
```

---

### **Level 3: Dependencies & Testing**

**Goal:** Manage external libraries automatically and run tests.

#### 3.1 FetchContent (The Modern Way)

Don't ask users to install libraries manually. Use `FetchContent` to download them at configure time.

```cmake
include(FetchContent)

# 1. Declare the dependency
FetchContent_Declare(
  fmt
  GIT_REPOSITORY https://github.com/fmtlib/fmt.git
  GIT_TAG        10.1.1 # Always pin a tag/hash!
)

# 2. Make it available (downloads & adds targets)
FetchContent_MakeAvailable(fmt)

# 3. Link it
add_executable(MyApp main.cpp)
target_link_libraries(MyApp PRIVATE fmt::fmt)
```

#### 3.2 Testing with GoogleTest

CMake has a built-in test runner called `CTest`.

```cmake
enable_testing() # Must be in the top-level CMakeLists.txt

# Fetch GoogleTest
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG        v1.14.0
)
# Prevent GoogleTest from overriding your compiler flags (Windows specifically)
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Create a test executable
add_executable(UnitTests tests/test_main.cpp)
target_link_libraries(UnitTests PRIVATE GTest::gtest_main)

# Auto-discover tests (Better than add_test)
include(GoogleTest)
gtest_discover_tests(UnitTests)
```

**To run tests:** `cd build && ctest`

---

### **Level 4: Professional Distribution**

**Goal:** Make your library installable and usable by others via `find_package(MyLib)`.

This is the hardest part for most people. You need to export your **Targets** and generate a **Config** file.

```cmake
include(GNUInstallDirs) # Defines standard paths (bin, lib, include)

# 1. Install the Targets
install(TARGETS MathLib
    EXPORT MathLibTargets          # Create a grouping name
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} # Important for consumers!
)

# 2. Install the Headers
install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

# 3. Generate and Install the Export File
# This allows others to use `target_link_libraries(App MathLib::MathLib)`
install(EXPORT MathLibTargets
    FILE MathLibTargets.cmake
    NAMESPACE MathLib::
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathLib
)

# 4. Generate Config Version file (so find_package checks version)
include(CMakePackageConfigHelpers)
write_basic_package_version_file(
    "MathLibConfigVersion.cmake"
    VERSION ${PROJECT_VERSION}
    COMPATIBILITY SameMajorVersion
)

# 5. Create a simple Config file manually or configure one
file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfig.cmake"
    "include(\"\${CMAKE_CURRENT_LIST_DIR}/MathLibTargets.cmake\")\n"
)

install(FILES
    "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfig.cmake"
    "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfigVersion.cmake"
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathLib
)
```

---

### **Level 5: Advanced Concepts**

**Goal:** Optimization, Cross-Compilation, and Workflow Standards.

#### 5.1 Generator Expressions

These are conditional logic that happens _during build file generation_, not configuration.
Syntax: `$<CONDITION:VALUE>`

- **Different flags for Debug vs Release:**
  ```cmake
  target_compile_options(MyLib PRIVATE
      $<$<CONFIG:Debug>:-g -O0>
      $<$<CONFIG:Release>:-O3 -march=native>
  )
  ```
- **Compile features only when building (not for consumers):**
  ```cmake
  target_include_directories(MyLib PUBLIC
      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
      $<INSTALL_INTERFACE:include>
  )
  ```

#### 5.2 CMakePresets.json

Stop typing `cmake -DCMAKE_BUILD_TYPE=Release -G Ninja ..` repeatedly. Use a `CMakePresets.json` file in your root to standardize builds for your team/CI.

```json
{
  "version": 3,
  "configurePresets": [
    {
      "name": "dev-debug",
      "displayName": "Developer Debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/debug",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
      }
    }
  ]
}
```

**Usage:** `cmake --preset dev-debug`

#### 5.3 Cross-Compilation (Toolchains)

To build for a different architecture (e.g., ARM Linux on x86 Windows), you use a **Toolchain File**.

**toolchain-arm.cmake:**

```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

set(CMAKE_C_COMPILER   arm-linux-gnueabi-gcc)
set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) # Use host tools
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)  # Use target libs
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)  # Use target headers
```

**Usage:** `cmake -DCMAKE_TOOLCHAIN_FILE=toolchain-arm.cmake ..`

---

### **Summary Checklist**

1.  **Always** use `target_` commands (compile_definitions, include_directories, link_libraries).
2.  **Always** use out-of-source builds (`mkdir build`).
3.  **Prefer** `FetchContent` over Git Submodules for dependencies.
4.  **Use** `CMakePresets.json` to share build configurations with your team.
5.  **Use** `install(EXPORT)` if you intend to distribute your library.
